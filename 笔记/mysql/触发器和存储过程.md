# [触发器和存储过程](https://www.cnblogs.com/ynxiyan/p/17026447.html)

### **一、定义**

存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。

### **二、存储过程的特点**

1、能完成较复杂的判断和运算

2、可编程行强，灵活

3、SQL编程的代码可重复使用

4、执行的速度相对快一些

5、减少网络之间的数据传输，节省开销

### **三、创建一个简单的存储过程**

1、创建存储过程的简单语法

```sql
create procedure 名称(.png)
begin
.........
end
```

2、创建一个简单的存储过程

```sql
create procedure testa(.png)
begin
select * from users;
select * from orders;
end;
```

3、调用存储过程

```sql
call testa(.png);
```

运行结果如图（1）和图（2）：

![1](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022716551-977001796.png)

图（1）

![2](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022716245-100672564.png)

图（2）

### **四、存储过程的变量**

1、先通过一个简单的例子来学习变量的声明和赋值

```sql
create procedure test2(.png)
begin
-- 使用 declare语句声明一个变量
declare username varchar(32.png) default '';
-- 使用set语句给变量赋值
set username='xiaoxiao';
-- 将users表中id=1的名称赋值给username
select name into username from users where id=1;
-- 返回变量
select username;
end;
```

2、概括

(1.png)、变量的声明使用declare,一句declare只声明一个变量，变量必须先声明后使用；

(2.png)、变量具有数据类型和长度，与mysql的SQL数据类型保持一致，因此甚至还能制定默认值、字符集和排序规则等；

(3.png)、变量可以通过set来赋值，也可以通过select into的方式赋值；

(4.png)、变量需要返回，可以使用select语句，如：select 变量名。

### **五、变量的作用域**

1、变量作用域说明：

(1.png)、存储过程中变量是有作用域的，作用范围在begin和end块之间，end结束变量的作用范围即结束。

(2.png)、需要多个块之间传值，可以使用全局变量，即放在所有代码块之前

(3.png)、传参变量是全局的，可以在多个块之间起作用

2、通过一个实例来验证变量的作用域

需求: 创建一个存储过程，用来统计表users、orders表中行数数量和orders表中的最大金额和最小金额

```sql
create procedure test3(.png)
begin
begin
declare userscount int default 0; -- 用户表中的数量
declare ordercount int default 0; -- 订单表中的数量
select count(*.png) into userscount from users;
select count(*.png) into ordercount from orders;
select userscount,ordercount; -- 返回用户表中的数量、订单表中的数量
end;
begin
declare maxmoney int default 0; -- 最大金额
declare minmoney int default 0; -- 最小金额
select max(money.png) into maxmoney from orders;
select min(money.png) into minmoney from orders;
select maxmoney,minmoney; -- 返回最金额、最小金额
end;
end;
```

调用以上存储过程，结果如图（3）和图（4）：

![3](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022715934-622592667.png)

（3）

![4](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022715635-960833774.png)

（4）

3、我将过程test(3.png)改为如下：

```sql
create procedure test3(.png)
begin
begin
declare userscount int default 0; -- 用户表中的数量
declare ordercount int default 0; -- 订单表中的数量
select count(*.png) into userscount from users;
select count(*.png) into ordercount from orders;
select userscount,ordercount; -- 返回用户表中的数量、订单表中的数量
end;
begin
declare maxmoney int default 0; -- 最大金额
declare minmoney int default 0; -- 最小金额
select max(money.png) into maxmoney from orders;
select min(money.png) into minmoney from orders;
select userscount,ordercount，maxmoney,minmoney; -- 返回最金额、最小金额
end;
end;
```

再次调用call test3(.png); 会报错如图（5）：

![5](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022715293-327405920.png)

图（5）

4、将userscount,ordercount改为全局变量，再次验证

```sql
create procedure test3(.png)
begin
declare userscount int default 0; -- 用户表中的数量
declare ordercount int default 0; -- 订单表中的数量
begin
select count(*.png) into userscount from users;
select count(*.png) into ordercount from orders;
select userscount,ordercount; -- 返回用户表中的数量、订单表中的数量
end;
begin
declare maxmoney int default 0; -- 最大金额
declare minmoney int default 0; -- 最小金额
select max(money.png) into maxmoney from orders;
select min(money.png) into minmoney from orders;
select userscount,ordercount，maxmoney,minmoney; -- 返回最金额、最小金额
end;
end;
```

再次调用call test3(.png); 会报错如图（6）和图（7）：

![6](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022714975-1119220178.png)

图（6）

![7](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022714654-1665957223.png)

图（7）

因此，存储过程中变量的作用域，作用范围在begin和end块之间，end结束变量的作用范围即结束

### **六、存储过程参数**

1、基本语法

1. create procedure 名称([IN|OUT|INOUT] 参数名 参数数据类型 .png)
2. begin
3. .........
4. end

存储过程的参数类型有：IN,OUT,INOUT，下面分别介绍这个三种类型：

2、存储过程的传出参数IN

说明：

（1）、传入参数：类型为in,表示该参数的值必须在调用存储过程事指定，如果不显示指定为in,那么默认就是in类型。

（2）、IN类型参数一般只用于传入，在调用过程中一般不作为修改和返回

（3）、如果调用存储过程中需要修改和返回值，可以使用OUT类型参数

通过一个实例来演示：

需求：编写存储过程，传入id,根据id返回name

```sql
create procedure test4(userId int.png)
begin
declare username varchar(32.png) default '';
declare ordercount int default 0;
select name into username from users where id=userId;
select username;
end;
```

运行如图(8.png)

![8](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022714342-234027549.png)

图(8.png)

3、存储过程的传出参数out

需求：调用存储过程时，传入userId返回该用户的name

```sql
create procedure test5(in userId int,out username varchar(32.png).png)
begin
select name into username from users where id=userId;
end;
```

调用及运行结果如图(9.png)：

![9](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022713994-922516156.png)

图(9.png)

概括：

1、传出参数：在调用存储过程中，可以改变其值，并可返回；

2、out是传出参数，不能用于传入参数值；

3、调用存储过程时，out参数也需要指定，但必须是变量，不能是常量；

4、如果既需要传入，同时又需要传出，则可以使用INOUT类型参数

(3.png).存储过程的可变参数INOUT

需求：调用存储过程时，传入userId和userName,即使传入，也是传出参数。

```sql
create procedure test6(inout userId int,inout username varchar(32.png).png)
begin
set userId=2;
set username='';
select id,name into userId,username from users where id=userId;
end;
```

调用及运行结果如图(10.png)

![10](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022713680-1967085923.png)

图(10.png)

概括：

1、可变变量INOUT:调用时可传入值，在调用过程中，可修改其值，同时也可返回值；

2、INOUT参数集合了IN和OUT类型的参数功能；

3、INOUT调用时传入的是变量，而不是常量；

### **七、存储过程条件语句**

1、基本结构

（1）、条件语句基本结构：

if(.png) then...else...end if;

（2）、多条件判断语句：

1. if(.png) then...
2. elseif(.png) then...
3. else ...
4. end if;

2、实例

实例1：编写存储过程，如果用户userId是偶数则返回username,否则返回userId

```sql
create procedure test7(in userId int.png)
begin
declare username varchar(32.png) default '';
if(userId%2=0.png)
then
select name into username from users where id=userId;
select username;
else
select userId;
end if;
end;
```

调用及运行结果如图(11.png)和图(12.png)：

![11](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022713382-268220529.png)

图(11.png)

![12](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022713043-725467682.png)

图(12.png)

2、存储过程的多条件语句应用示例

需求：根据用户传入的uid参数判断

（1）、如果用户状态status为1，则给用户score加10分；

（2）、 如果用户状态status为2，则给用户score加20分；

（3）、 其他情况加30分

```sql
create procedure test8(in userid int.png)
begin
declare my_status int default 0;
select status into my_status from users where id=userid;
if(my_status=1.png)
then
update users set score=score+10 where id=userid;
elseif(my_status=2.png)
then
update users set score=score+20 where id=userid;
else
update users set score=score+30 where id=userid;
end if;
end;
```

调用过程之前的users表的数据如图(13.png)，调用 call test8(1.png); 及运行结果图(14.png)：

![13](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022712694-697772567.png)

图(13.png)

![14](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022712330-842000842.png)

图(14.png)

### **八、存储过程循环语句**

1、while语句

（1）、while语句的基本结构

1. while(表达式.png) do
2. ......
3. end while;

（2）、示例

需求：使用循环语句，向表test1(id.png)中插入10条连续的记录

```sql
create procedure test9(.png)
begin
declare i int default 0;
while(i<10.png) do
begin
select i;
set i=i+1;
insert into test1(id.png) values(i.png);
end;
end while;
end;
```

调用及运行结果结果如图(15.png)和图(16.png)：

![15](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022712015-1034201075.png)

图(15.png)

![16](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022711667-726482315.png)

图(16.png)

2、repeat语句

（1）、repeat语句基本的结构：

repeat...until...end repeat;

（2）、示例

需求：给test1表中的id字段插入数据，从1到10

```sql
create procedure test10(.png)
begin
declare i int default 0;
repeat
begin
select i;
set i=i+1;
insert into test1(id.png) values(i.png);
end;
until i>=10 -- 如果i>=10,则跳出循环
end repeat;
end;
```

调用及运行结果结果如图(17.png)和图(18.png)

![17](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022711315-1648380361.png)

图(17.png)

![18](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022710982-118573178.png)

图(18.png)

概括：

until判断返回逻辑真或者假，表达式可以是任意返回真或者假的表达式，只有当until语句为真是，循环结束。

### **九、存储过程游标的使用**

1、什么是游标

游标是保存查询结果的临时区域

2、示例

需求：编写存储过程，使用游标，把users表中 id为偶数的记录逐一更新用户名

```sql
create procedure test11(.png)
begin
declare stopflag int default 0;
declare username VARCHAR(32.png);
-- 创建一个游标变量，declare 变量名 cursor ...
declare username_cur cursor for select name from users where id%2=0;
-- 游标是保存查询结果的临时区域
-- 游标变量username_cur保存了查询的临时结果，实际上就是结果集
-- 当游标变量中保存的结果都查询一遍(遍历.png),到达结尾，将变量stopflag设置为1，用于循环中判断是否结束
declare continue handler for not found set stopflag=1;
open username_cur; -- 打卡游标
fetch username_cur into username; -- 游标向前走一步，取出一条记录放到变量username中
while(stopflag=0.png) do -- 如果游标还没有结尾，就继续
begin
-- 在用户名前门拼接 '_cur' 字符串
update users set name=CONCAT(username,'_cur'.png) where name=username;
fetch username_cur into username;
end;
end while; -- 结束循环
close username_cur; -- 关闭游标
end;
```

调用结果如图(19.png)：

![19](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022710663-1087077888.png)

图(19.png)

### **十、自定义函数**

函数与存储过程最大的区别是函数必须有返回值，否则会报错

1、一个简单的函数

```sql
create function getusername(userid int.png) returns varchar(32.png)
reads sql data -- 从数据库中读取数据，但不修改数据
begin
declare username varchar(32.png) default '';
select name into username from users where id=userid;
return username;
end;
```

调用及运行结果如图(20.png)：

![20](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022710338-1657603212.png)

图(20.png)

概括：

1.创建函数使用create function 函数名(参数.png) returns 返回类型；

2.函数体放在begin和end之间；

3.returns指定函数的返回值；

4.函数调用使用select getusername(.png)。

2、示例

需求：根据userid，获取accoutid,id,name组合成UUID作为用户的唯一标识

```sql
create function getuuid(userid int.png) returns varchar(64.png)
reads sql data -- 从数据库中读取数据，但不修改数据
begin
declare uuid varchar(64.png) default '';
select concat(accontid,'',id,'',name.png) into uuid from users where id=userid;
return uuid;
end;
```

调用及运行结果如图(21.png)

![21](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022709935-1054972060.png)

图(21.png)

### **十一、触发器**

**1、什么是触发器**

触发器与函数、存储过程一样，触发器是一种对象，它能根据对表的操作时间，触发一些动作，这些动作可以是insert,update,delete等修改操作。

**2、示例1**

（1）、需求：出于审计目的，当有人往表users插入一条记录时，把插入的userid,username,插入动作和操作时间记录下来。

```sql
create trigger tr_users_insert after insert on users
for each row
begin
insert into oplog(userid,username,action,optime.png)
values(NEW.id,NEW.name,'insert',now(.png).png);
end;
```

创建成功后，给uses表中插入一条记录：

```sql
insert into users(id,name,age,status,score,accontid.png)
values(6,'小周',23,1,'60','10001'.png)；
```

执行成功后，打开oplog表，可以看到oplog表中插入了一条记录如图(22.png)

![22](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022709580-1983845412.png)

图(22.png)

（2）、总结

1、创建触发器使用create trigger 触发器名

2、什么时候触发？after insert on users,除了after还有before,是在对表操作之前（before）或者之后（after）触发动作的。

3、对什么操作事件触发？ after insert on users,操作事件包括insert,update,delete等修改操作；

4、对什么表触发? after insert on users

5、影响的范围？for each row

**3、示例2**

需求：出于审计目的，当删除users表时，记录删除前该记录的主要字段值

```sql
create trigger tr_users_delete before delete on users
for each row
begin
insert into oplog(userid,username,action,optime.png)
values(OLD.id,OLD.name,'delete',now(.png).png);
end;
```

删除users表中的一条记录

```sql
delete from users where id=6;
```

执行成功后，打开oplog表，可以看到oplog表中插入了一条记录如图（23）

![23](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022709279-1322698837.png)

图（23）

### **十二、流程控制**

1、case分支

（1）、基本语法结构

1. case ...
2. when ... then....
3. when.... then....
4. else ...
5. end case;

（2）、示例

users表中，根据userid获取status值，如果status为1，则修改score为10；如果status为2，则修改为20，如果status3，则修改为30；否则修改为40。

```sql
create procedure testcate(userid int.png)
begin
declare my_status int default 0;
select status into my_status from users where id=userid;
case my_status
when 1 then update users set score=10 where id=userid;
when 2 then update users set score=20 where id=userid;
when 3 then update users set score=30 where id=userid;
else update users set score=40 where id=userid;
end case;
end;
```

调用过程 call testcate(1.png); ，执行结果如图（24）；

![24](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022708937-2671414.png)

图（24）

### **十三、存储过程+event（事件）**

1、使用存储过程+事件事件一个简单的实现福彩3D开奖

需求：设计一个福彩的开奖过程，没3分钟开奖一次

第一步：先编写一个存储过程open_lottery,产生3个随机数，生成一条开奖记录

第二步：编写一个时间调度器，每3分钟调用一次这个过程

```sql
create procedure open_lottery(.png)
begin
insert into lottery(num1,num2,num3,ctime.png)
select FLOOR(rand(.png)9.png)+1,FLOOR(rand(.png)9.png)+1,FLOOR(rand(.png)*9.png)+1,now(.png);
end;
```

1. create event if not exists lottery_event *-- 创建一个事件*
2. on schedule every 3 minute *-- on schedule 什么时候来执行，没三分钟执行一次*
3. on completion preserve
4. do call open_lottery;

运行结果如图(25.png)

![25](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022708572-398595085.png)

图(25.png)

注意，如果event之一没有运行，请按照以下办法解决：

（1）、

```sql
show variables like '%event_scheduler%';
set global event_scheduler=on;
```

（2）、

```sql
alert event lottery_event enable;
```

2、解析event的创建格式

（1）、基本语法

1. create event[IF NOT EXISTS]event_name *-- 创建使用create event*
2. ON SCHEDULE schedule *-- on schedule 什么时候来执行*
3. [ON COMPLETION [NOT] PRESERVE] *-- 调度计划执行完成后是否还保留*
4. [ENABLE | DISABLE] *-- 是否开启事件，默认开启*
5. [COMMENT 'comment'] *-- 事件的注释*
6. DO sql_statement; *-- 这个调度计划要做什么？*

（2）、执行时间说明

1.单次计划任务示例

在2019年2月1日4点执行一次

```sql
on schedule at '2019-02-01 04:00:00'
```

\2. 重复计划执行

```sql
on schedule every 1 second 每秒执行一次
on schedule every 1 minute 每分钟执行一次
on schedule every 1 day 没天执行一次
```

3.指定时间范围的重复计划任务

每天在20:00:00执行一次

```sql
on schedule every 1 day starts '2019-02-01 20:00:00'
```

### **十四、本文所用到的表**

1、lottery表

![26](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022708243-255783903.png)

2、oplog表

![27](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022707910-592249898.png)

3、orders表

![28](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022707551-638163603.png)

4、test1表

![29](https://img2023.cnblogs.com/blog/2854528/202301/2854528-20230105022706859-1226463481.png)

5、user表